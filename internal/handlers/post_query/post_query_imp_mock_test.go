// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package postquery

//go:generate minimock -i github.com/nabishec/ozon_habr_api/internal/handlers/post_query.PostQueryImp -o post_query_imp_mock_test.go -n PostQueryImpMock -p postquery

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/nabishec/ozon_habr_api/internal/model"
)

// PostQueryImpMock implements PostQueryImp
type PostQueryImpMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetAllPosts          func(ctx context.Context) (ppa1 []*model.Post, err error)
	funcGetAllPostsOrigin    string
	inspectFuncGetAllPosts   func(ctx context.Context)
	afterGetAllPostsCounter  uint64
	beforeGetAllPostsCounter uint64
	GetAllPostsMock          mPostQueryImpMockGetAllPosts

	funcGetPost          func(ctx context.Context, postID int64) (pp1 *model.Post, err error)
	funcGetPostOrigin    string
	inspectFuncGetPost   func(ctx context.Context, postID int64)
	afterGetPostCounter  uint64
	beforeGetPostCounter uint64
	GetPostMock          mPostQueryImpMockGetPost
}

// NewPostQueryImpMock returns a mock for PostQueryImp
func NewPostQueryImpMock(t minimock.Tester) *PostQueryImpMock {
	m := &PostQueryImpMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAllPostsMock = mPostQueryImpMockGetAllPosts{mock: m}
	m.GetAllPostsMock.callArgs = []*PostQueryImpMockGetAllPostsParams{}

	m.GetPostMock = mPostQueryImpMockGetPost{mock: m}
	m.GetPostMock.callArgs = []*PostQueryImpMockGetPostParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPostQueryImpMockGetAllPosts struct {
	optional           bool
	mock               *PostQueryImpMock
	defaultExpectation *PostQueryImpMockGetAllPostsExpectation
	expectations       []*PostQueryImpMockGetAllPostsExpectation

	callArgs []*PostQueryImpMockGetAllPostsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostQueryImpMockGetAllPostsExpectation specifies expectation struct of the PostQueryImp.GetAllPosts
type PostQueryImpMockGetAllPostsExpectation struct {
	mock               *PostQueryImpMock
	params             *PostQueryImpMockGetAllPostsParams
	paramPtrs          *PostQueryImpMockGetAllPostsParamPtrs
	expectationOrigins PostQueryImpMockGetAllPostsExpectationOrigins
	results            *PostQueryImpMockGetAllPostsResults
	returnOrigin       string
	Counter            uint64
}

// PostQueryImpMockGetAllPostsParams contains parameters of the PostQueryImp.GetAllPosts
type PostQueryImpMockGetAllPostsParams struct {
	ctx context.Context
}

// PostQueryImpMockGetAllPostsParamPtrs contains pointers to parameters of the PostQueryImp.GetAllPosts
type PostQueryImpMockGetAllPostsParamPtrs struct {
	ctx *context.Context
}

// PostQueryImpMockGetAllPostsResults contains results of the PostQueryImp.GetAllPosts
type PostQueryImpMockGetAllPostsResults struct {
	ppa1 []*model.Post
	err  error
}

// PostQueryImpMockGetAllPostsOrigins contains origins of expectations of the PostQueryImp.GetAllPosts
type PostQueryImpMockGetAllPostsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllPosts *mPostQueryImpMockGetAllPosts) Optional() *mPostQueryImpMockGetAllPosts {
	mmGetAllPosts.optional = true
	return mmGetAllPosts
}

// Expect sets up expected params for PostQueryImp.GetAllPosts
func (mmGetAllPosts *mPostQueryImpMockGetAllPosts) Expect(ctx context.Context) *mPostQueryImpMockGetAllPosts {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("PostQueryImpMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &PostQueryImpMockGetAllPostsExpectation{}
	}

	if mmGetAllPosts.defaultExpectation.paramPtrs != nil {
		mmGetAllPosts.mock.t.Fatalf("PostQueryImpMock.GetAllPosts mock is already set by ExpectParams functions")
	}

	mmGetAllPosts.defaultExpectation.params = &PostQueryImpMockGetAllPostsParams{ctx}
	mmGetAllPosts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllPosts.expectations {
		if minimock.Equal(e.params, mmGetAllPosts.defaultExpectation.params) {
			mmGetAllPosts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllPosts.defaultExpectation.params)
		}
	}

	return mmGetAllPosts
}

// ExpectCtxParam1 sets up expected param ctx for PostQueryImp.GetAllPosts
func (mmGetAllPosts *mPostQueryImpMockGetAllPosts) ExpectCtxParam1(ctx context.Context) *mPostQueryImpMockGetAllPosts {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("PostQueryImpMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &PostQueryImpMockGetAllPostsExpectation{}
	}

	if mmGetAllPosts.defaultExpectation.params != nil {
		mmGetAllPosts.mock.t.Fatalf("PostQueryImpMock.GetAllPosts mock is already set by Expect")
	}

	if mmGetAllPosts.defaultExpectation.paramPtrs == nil {
		mmGetAllPosts.defaultExpectation.paramPtrs = &PostQueryImpMockGetAllPostsParamPtrs{}
	}
	mmGetAllPosts.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllPosts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllPosts
}

// Inspect accepts an inspector function that has same arguments as the PostQueryImp.GetAllPosts
func (mmGetAllPosts *mPostQueryImpMockGetAllPosts) Inspect(f func(ctx context.Context)) *mPostQueryImpMockGetAllPosts {
	if mmGetAllPosts.mock.inspectFuncGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("Inspect function is already set for PostQueryImpMock.GetAllPosts")
	}

	mmGetAllPosts.mock.inspectFuncGetAllPosts = f

	return mmGetAllPosts
}

// Return sets up results that will be returned by PostQueryImp.GetAllPosts
func (mmGetAllPosts *mPostQueryImpMockGetAllPosts) Return(ppa1 []*model.Post, err error) *PostQueryImpMock {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("PostQueryImpMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &PostQueryImpMockGetAllPostsExpectation{mock: mmGetAllPosts.mock}
	}
	mmGetAllPosts.defaultExpectation.results = &PostQueryImpMockGetAllPostsResults{ppa1, err}
	mmGetAllPosts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllPosts.mock
}

// Set uses given function f to mock the PostQueryImp.GetAllPosts method
func (mmGetAllPosts *mPostQueryImpMockGetAllPosts) Set(f func(ctx context.Context) (ppa1 []*model.Post, err error)) *PostQueryImpMock {
	if mmGetAllPosts.defaultExpectation != nil {
		mmGetAllPosts.mock.t.Fatalf("Default expectation is already set for the PostQueryImp.GetAllPosts method")
	}

	if len(mmGetAllPosts.expectations) > 0 {
		mmGetAllPosts.mock.t.Fatalf("Some expectations are already set for the PostQueryImp.GetAllPosts method")
	}

	mmGetAllPosts.mock.funcGetAllPosts = f
	mmGetAllPosts.mock.funcGetAllPostsOrigin = minimock.CallerInfo(1)
	return mmGetAllPosts.mock
}

// When sets expectation for the PostQueryImp.GetAllPosts which will trigger the result defined by the following
// Then helper
func (mmGetAllPosts *mPostQueryImpMockGetAllPosts) When(ctx context.Context) *PostQueryImpMockGetAllPostsExpectation {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("PostQueryImpMock.GetAllPosts mock is already set by Set")
	}

	expectation := &PostQueryImpMockGetAllPostsExpectation{
		mock:               mmGetAllPosts.mock,
		params:             &PostQueryImpMockGetAllPostsParams{ctx},
		expectationOrigins: PostQueryImpMockGetAllPostsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllPosts.expectations = append(mmGetAllPosts.expectations, expectation)
	return expectation
}

// Then sets up PostQueryImp.GetAllPosts return parameters for the expectation previously defined by the When method
func (e *PostQueryImpMockGetAllPostsExpectation) Then(ppa1 []*model.Post, err error) *PostQueryImpMock {
	e.results = &PostQueryImpMockGetAllPostsResults{ppa1, err}
	return e.mock
}

// Times sets number of times PostQueryImp.GetAllPosts should be invoked
func (mmGetAllPosts *mPostQueryImpMockGetAllPosts) Times(n uint64) *mPostQueryImpMockGetAllPosts {
	if n == 0 {
		mmGetAllPosts.mock.t.Fatalf("Times of PostQueryImpMock.GetAllPosts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllPosts.expectedInvocations, n)
	mmGetAllPosts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllPosts
}

func (mmGetAllPosts *mPostQueryImpMockGetAllPosts) invocationsDone() bool {
	if len(mmGetAllPosts.expectations) == 0 && mmGetAllPosts.defaultExpectation == nil && mmGetAllPosts.mock.funcGetAllPosts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllPosts.mock.afterGetAllPostsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllPosts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllPosts implements PostQueryImp
func (mmGetAllPosts *PostQueryImpMock) GetAllPosts(ctx context.Context) (ppa1 []*model.Post, err error) {
	mm_atomic.AddUint64(&mmGetAllPosts.beforeGetAllPostsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllPosts.afterGetAllPostsCounter, 1)

	mmGetAllPosts.t.Helper()

	if mmGetAllPosts.inspectFuncGetAllPosts != nil {
		mmGetAllPosts.inspectFuncGetAllPosts(ctx)
	}

	mm_params := PostQueryImpMockGetAllPostsParams{ctx}

	// Record call args
	mmGetAllPosts.GetAllPostsMock.mutex.Lock()
	mmGetAllPosts.GetAllPostsMock.callArgs = append(mmGetAllPosts.GetAllPostsMock.callArgs, &mm_params)
	mmGetAllPosts.GetAllPostsMock.mutex.Unlock()

	for _, e := range mmGetAllPosts.GetAllPostsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmGetAllPosts.GetAllPostsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllPosts.GetAllPostsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllPosts.GetAllPostsMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllPosts.GetAllPostsMock.defaultExpectation.paramPtrs

		mm_got := PostQueryImpMockGetAllPostsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllPosts.t.Errorf("PostQueryImpMock.GetAllPosts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllPosts.GetAllPostsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllPosts.t.Errorf("PostQueryImpMock.GetAllPosts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllPosts.GetAllPostsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllPosts.GetAllPostsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllPosts.t.Fatal("No results are set for the PostQueryImpMock.GetAllPosts")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmGetAllPosts.funcGetAllPosts != nil {
		return mmGetAllPosts.funcGetAllPosts(ctx)
	}
	mmGetAllPosts.t.Fatalf("Unexpected call to PostQueryImpMock.GetAllPosts. %v", ctx)
	return
}

// GetAllPostsAfterCounter returns a count of finished PostQueryImpMock.GetAllPosts invocations
func (mmGetAllPosts *PostQueryImpMock) GetAllPostsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllPosts.afterGetAllPostsCounter)
}

// GetAllPostsBeforeCounter returns a count of PostQueryImpMock.GetAllPosts invocations
func (mmGetAllPosts *PostQueryImpMock) GetAllPostsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllPosts.beforeGetAllPostsCounter)
}

// Calls returns a list of arguments used in each call to PostQueryImpMock.GetAllPosts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllPosts *mPostQueryImpMockGetAllPosts) Calls() []*PostQueryImpMockGetAllPostsParams {
	mmGetAllPosts.mutex.RLock()

	argCopy := make([]*PostQueryImpMockGetAllPostsParams, len(mmGetAllPosts.callArgs))
	copy(argCopy, mmGetAllPosts.callArgs)

	mmGetAllPosts.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllPostsDone returns true if the count of the GetAllPosts invocations corresponds
// the number of defined expectations
func (m *PostQueryImpMock) MinimockGetAllPostsDone() bool {
	if m.GetAllPostsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllPostsMock.invocationsDone()
}

// MinimockGetAllPostsInspect logs each unmet expectation
func (m *PostQueryImpMock) MinimockGetAllPostsInspect() {
	for _, e := range m.GetAllPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostQueryImpMock.GetAllPosts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllPostsCounter := mm_atomic.LoadUint64(&m.afterGetAllPostsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllPostsMock.defaultExpectation != nil && afterGetAllPostsCounter < 1 {
		if m.GetAllPostsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostQueryImpMock.GetAllPosts at\n%s", m.GetAllPostsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostQueryImpMock.GetAllPosts at\n%s with params: %#v", m.GetAllPostsMock.defaultExpectation.expectationOrigins.origin, *m.GetAllPostsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllPosts != nil && afterGetAllPostsCounter < 1 {
		m.t.Errorf("Expected call to PostQueryImpMock.GetAllPosts at\n%s", m.funcGetAllPostsOrigin)
	}

	if !m.GetAllPostsMock.invocationsDone() && afterGetAllPostsCounter > 0 {
		m.t.Errorf("Expected %d calls to PostQueryImpMock.GetAllPosts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllPostsMock.expectedInvocations), m.GetAllPostsMock.expectedInvocationsOrigin, afterGetAllPostsCounter)
	}
}

type mPostQueryImpMockGetPost struct {
	optional           bool
	mock               *PostQueryImpMock
	defaultExpectation *PostQueryImpMockGetPostExpectation
	expectations       []*PostQueryImpMockGetPostExpectation

	callArgs []*PostQueryImpMockGetPostParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostQueryImpMockGetPostExpectation specifies expectation struct of the PostQueryImp.GetPost
type PostQueryImpMockGetPostExpectation struct {
	mock               *PostQueryImpMock
	params             *PostQueryImpMockGetPostParams
	paramPtrs          *PostQueryImpMockGetPostParamPtrs
	expectationOrigins PostQueryImpMockGetPostExpectationOrigins
	results            *PostQueryImpMockGetPostResults
	returnOrigin       string
	Counter            uint64
}

// PostQueryImpMockGetPostParams contains parameters of the PostQueryImp.GetPost
type PostQueryImpMockGetPostParams struct {
	ctx    context.Context
	postID int64
}

// PostQueryImpMockGetPostParamPtrs contains pointers to parameters of the PostQueryImp.GetPost
type PostQueryImpMockGetPostParamPtrs struct {
	ctx    *context.Context
	postID *int64
}

// PostQueryImpMockGetPostResults contains results of the PostQueryImp.GetPost
type PostQueryImpMockGetPostResults struct {
	pp1 *model.Post
	err error
}

// PostQueryImpMockGetPostOrigins contains origins of expectations of the PostQueryImp.GetPost
type PostQueryImpMockGetPostExpectationOrigins struct {
	origin       string
	originCtx    string
	originPostID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPost *mPostQueryImpMockGetPost) Optional() *mPostQueryImpMockGetPost {
	mmGetPost.optional = true
	return mmGetPost
}

// Expect sets up expected params for PostQueryImp.GetPost
func (mmGetPost *mPostQueryImpMockGetPost) Expect(ctx context.Context, postID int64) *mPostQueryImpMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("PostQueryImpMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &PostQueryImpMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.paramPtrs != nil {
		mmGetPost.mock.t.Fatalf("PostQueryImpMock.GetPost mock is already set by ExpectParams functions")
	}

	mmGetPost.defaultExpectation.params = &PostQueryImpMockGetPostParams{ctx, postID}
	mmGetPost.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPost.expectations {
		if minimock.Equal(e.params, mmGetPost.defaultExpectation.params) {
			mmGetPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPost.defaultExpectation.params)
		}
	}

	return mmGetPost
}

// ExpectCtxParam1 sets up expected param ctx for PostQueryImp.GetPost
func (mmGetPost *mPostQueryImpMockGetPost) ExpectCtxParam1(ctx context.Context) *mPostQueryImpMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("PostQueryImpMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &PostQueryImpMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.params != nil {
		mmGetPost.mock.t.Fatalf("PostQueryImpMock.GetPost mock is already set by Expect")
	}

	if mmGetPost.defaultExpectation.paramPtrs == nil {
		mmGetPost.defaultExpectation.paramPtrs = &PostQueryImpMockGetPostParamPtrs{}
	}
	mmGetPost.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPost.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPost
}

// ExpectPostIDParam2 sets up expected param postID for PostQueryImp.GetPost
func (mmGetPost *mPostQueryImpMockGetPost) ExpectPostIDParam2(postID int64) *mPostQueryImpMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("PostQueryImpMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &PostQueryImpMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.params != nil {
		mmGetPost.mock.t.Fatalf("PostQueryImpMock.GetPost mock is already set by Expect")
	}

	if mmGetPost.defaultExpectation.paramPtrs == nil {
		mmGetPost.defaultExpectation.paramPtrs = &PostQueryImpMockGetPostParamPtrs{}
	}
	mmGetPost.defaultExpectation.paramPtrs.postID = &postID
	mmGetPost.defaultExpectation.expectationOrigins.originPostID = minimock.CallerInfo(1)

	return mmGetPost
}

// Inspect accepts an inspector function that has same arguments as the PostQueryImp.GetPost
func (mmGetPost *mPostQueryImpMockGetPost) Inspect(f func(ctx context.Context, postID int64)) *mPostQueryImpMockGetPost {
	if mmGetPost.mock.inspectFuncGetPost != nil {
		mmGetPost.mock.t.Fatalf("Inspect function is already set for PostQueryImpMock.GetPost")
	}

	mmGetPost.mock.inspectFuncGetPost = f

	return mmGetPost
}

// Return sets up results that will be returned by PostQueryImp.GetPost
func (mmGetPost *mPostQueryImpMockGetPost) Return(pp1 *model.Post, err error) *PostQueryImpMock {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("PostQueryImpMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &PostQueryImpMockGetPostExpectation{mock: mmGetPost.mock}
	}
	mmGetPost.defaultExpectation.results = &PostQueryImpMockGetPostResults{pp1, err}
	mmGetPost.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPost.mock
}

// Set uses given function f to mock the PostQueryImp.GetPost method
func (mmGetPost *mPostQueryImpMockGetPost) Set(f func(ctx context.Context, postID int64) (pp1 *model.Post, err error)) *PostQueryImpMock {
	if mmGetPost.defaultExpectation != nil {
		mmGetPost.mock.t.Fatalf("Default expectation is already set for the PostQueryImp.GetPost method")
	}

	if len(mmGetPost.expectations) > 0 {
		mmGetPost.mock.t.Fatalf("Some expectations are already set for the PostQueryImp.GetPost method")
	}

	mmGetPost.mock.funcGetPost = f
	mmGetPost.mock.funcGetPostOrigin = minimock.CallerInfo(1)
	return mmGetPost.mock
}

// When sets expectation for the PostQueryImp.GetPost which will trigger the result defined by the following
// Then helper
func (mmGetPost *mPostQueryImpMockGetPost) When(ctx context.Context, postID int64) *PostQueryImpMockGetPostExpectation {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("PostQueryImpMock.GetPost mock is already set by Set")
	}

	expectation := &PostQueryImpMockGetPostExpectation{
		mock:               mmGetPost.mock,
		params:             &PostQueryImpMockGetPostParams{ctx, postID},
		expectationOrigins: PostQueryImpMockGetPostExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPost.expectations = append(mmGetPost.expectations, expectation)
	return expectation
}

// Then sets up PostQueryImp.GetPost return parameters for the expectation previously defined by the When method
func (e *PostQueryImpMockGetPostExpectation) Then(pp1 *model.Post, err error) *PostQueryImpMock {
	e.results = &PostQueryImpMockGetPostResults{pp1, err}
	return e.mock
}

// Times sets number of times PostQueryImp.GetPost should be invoked
func (mmGetPost *mPostQueryImpMockGetPost) Times(n uint64) *mPostQueryImpMockGetPost {
	if n == 0 {
		mmGetPost.mock.t.Fatalf("Times of PostQueryImpMock.GetPost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPost.expectedInvocations, n)
	mmGetPost.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPost
}

func (mmGetPost *mPostQueryImpMockGetPost) invocationsDone() bool {
	if len(mmGetPost.expectations) == 0 && mmGetPost.defaultExpectation == nil && mmGetPost.mock.funcGetPost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPost.mock.afterGetPostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPost implements PostQueryImp
func (mmGetPost *PostQueryImpMock) GetPost(ctx context.Context, postID int64) (pp1 *model.Post, err error) {
	mm_atomic.AddUint64(&mmGetPost.beforeGetPostCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPost.afterGetPostCounter, 1)

	mmGetPost.t.Helper()

	if mmGetPost.inspectFuncGetPost != nil {
		mmGetPost.inspectFuncGetPost(ctx, postID)
	}

	mm_params := PostQueryImpMockGetPostParams{ctx, postID}

	// Record call args
	mmGetPost.GetPostMock.mutex.Lock()
	mmGetPost.GetPostMock.callArgs = append(mmGetPost.GetPostMock.callArgs, &mm_params)
	mmGetPost.GetPostMock.mutex.Unlock()

	for _, e := range mmGetPost.GetPostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPost.GetPostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPost.GetPostMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPost.GetPostMock.defaultExpectation.params
		mm_want_ptrs := mmGetPost.GetPostMock.defaultExpectation.paramPtrs

		mm_got := PostQueryImpMockGetPostParams{ctx, postID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPost.t.Errorf("PostQueryImpMock.GetPost got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPost.GetPostMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmGetPost.t.Errorf("PostQueryImpMock.GetPost got unexpected parameter postID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPost.GetPostMock.defaultExpectation.expectationOrigins.originPostID, *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPost.t.Errorf("PostQueryImpMock.GetPost got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPost.GetPostMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPost.GetPostMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPost.t.Fatal("No results are set for the PostQueryImpMock.GetPost")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPost.funcGetPost != nil {
		return mmGetPost.funcGetPost(ctx, postID)
	}
	mmGetPost.t.Fatalf("Unexpected call to PostQueryImpMock.GetPost. %v %v", ctx, postID)
	return
}

// GetPostAfterCounter returns a count of finished PostQueryImpMock.GetPost invocations
func (mmGetPost *PostQueryImpMock) GetPostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPost.afterGetPostCounter)
}

// GetPostBeforeCounter returns a count of PostQueryImpMock.GetPost invocations
func (mmGetPost *PostQueryImpMock) GetPostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPost.beforeGetPostCounter)
}

// Calls returns a list of arguments used in each call to PostQueryImpMock.GetPost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPost *mPostQueryImpMockGetPost) Calls() []*PostQueryImpMockGetPostParams {
	mmGetPost.mutex.RLock()

	argCopy := make([]*PostQueryImpMockGetPostParams, len(mmGetPost.callArgs))
	copy(argCopy, mmGetPost.callArgs)

	mmGetPost.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostDone returns true if the count of the GetPost invocations corresponds
// the number of defined expectations
func (m *PostQueryImpMock) MinimockGetPostDone() bool {
	if m.GetPostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostMock.invocationsDone()
}

// MinimockGetPostInspect logs each unmet expectation
func (m *PostQueryImpMock) MinimockGetPostInspect() {
	for _, e := range m.GetPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostQueryImpMock.GetPost at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPostCounter := mm_atomic.LoadUint64(&m.afterGetPostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostMock.defaultExpectation != nil && afterGetPostCounter < 1 {
		if m.GetPostMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostQueryImpMock.GetPost at\n%s", m.GetPostMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostQueryImpMock.GetPost at\n%s with params: %#v", m.GetPostMock.defaultExpectation.expectationOrigins.origin, *m.GetPostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPost != nil && afterGetPostCounter < 1 {
		m.t.Errorf("Expected call to PostQueryImpMock.GetPost at\n%s", m.funcGetPostOrigin)
	}

	if !m.GetPostMock.invocationsDone() && afterGetPostCounter > 0 {
		m.t.Errorf("Expected %d calls to PostQueryImpMock.GetPost at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostMock.expectedInvocations), m.GetPostMock.expectedInvocationsOrigin, afterGetPostCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PostQueryImpMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetAllPostsInspect()

			m.MinimockGetPostInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PostQueryImpMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PostQueryImpMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAllPostsDone() &&
		m.MinimockGetPostDone()
}
