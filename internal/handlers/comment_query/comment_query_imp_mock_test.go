// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package commentquery

//go:generate minimock -i github.com/nabishec/ozon_habr_api/internal/handlers/comment_query.CommentQueryImp -o comment_query_imp_mock_test.go -n CommentQueryImpMock -p commentquery

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/nabishec/ozon_habr_api/internal/model"
)

// CommentQueryImpMock implements CommentQueryImp
type CommentQueryImpMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetCommentPath          func(ctx context.Context, parentID int64) (s1 string, err error)
	funcGetCommentPathOrigin    string
	inspectFuncGetCommentPath   func(ctx context.Context, parentID int64)
	afterGetCommentPathCounter  uint64
	beforeGetCommentPathCounter uint64
	GetCommentPathMock          mCommentQueryImpMockGetCommentPath

	funcGetCommentsBranch          func(ctx context.Context, postID int64, path string) (cpa1 []*model.Comment, err error)
	funcGetCommentsBranchOrigin    string
	inspectFuncGetCommentsBranch   func(ctx context.Context, postID int64, path string)
	afterGetCommentsBranchCounter  uint64
	beforeGetCommentsBranchCounter uint64
	GetCommentsBranchMock          mCommentQueryImpMockGetCommentsBranch
}

// NewCommentQueryImpMock returns a mock for CommentQueryImp
func NewCommentQueryImpMock(t minimock.Tester) *CommentQueryImpMock {
	m := &CommentQueryImpMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCommentPathMock = mCommentQueryImpMockGetCommentPath{mock: m}
	m.GetCommentPathMock.callArgs = []*CommentQueryImpMockGetCommentPathParams{}

	m.GetCommentsBranchMock = mCommentQueryImpMockGetCommentsBranch{mock: m}
	m.GetCommentsBranchMock.callArgs = []*CommentQueryImpMockGetCommentsBranchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCommentQueryImpMockGetCommentPath struct {
	optional           bool
	mock               *CommentQueryImpMock
	defaultExpectation *CommentQueryImpMockGetCommentPathExpectation
	expectations       []*CommentQueryImpMockGetCommentPathExpectation

	callArgs []*CommentQueryImpMockGetCommentPathParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentQueryImpMockGetCommentPathExpectation specifies expectation struct of the CommentQueryImp.GetCommentPath
type CommentQueryImpMockGetCommentPathExpectation struct {
	mock               *CommentQueryImpMock
	params             *CommentQueryImpMockGetCommentPathParams
	paramPtrs          *CommentQueryImpMockGetCommentPathParamPtrs
	expectationOrigins CommentQueryImpMockGetCommentPathExpectationOrigins
	results            *CommentQueryImpMockGetCommentPathResults
	returnOrigin       string
	Counter            uint64
}

// CommentQueryImpMockGetCommentPathParams contains parameters of the CommentQueryImp.GetCommentPath
type CommentQueryImpMockGetCommentPathParams struct {
	ctx      context.Context
	parentID int64
}

// CommentQueryImpMockGetCommentPathParamPtrs contains pointers to parameters of the CommentQueryImp.GetCommentPath
type CommentQueryImpMockGetCommentPathParamPtrs struct {
	ctx      *context.Context
	parentID *int64
}

// CommentQueryImpMockGetCommentPathResults contains results of the CommentQueryImp.GetCommentPath
type CommentQueryImpMockGetCommentPathResults struct {
	s1  string
	err error
}

// CommentQueryImpMockGetCommentPathOrigins contains origins of expectations of the CommentQueryImp.GetCommentPath
type CommentQueryImpMockGetCommentPathExpectationOrigins struct {
	origin         string
	originCtx      string
	originParentID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) Optional() *mCommentQueryImpMockGetCommentPath {
	mmGetCommentPath.optional = true
	return mmGetCommentPath
}

// Expect sets up expected params for CommentQueryImp.GetCommentPath
func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) Expect(ctx context.Context, parentID int64) *mCommentQueryImpMockGetCommentPath {
	if mmGetCommentPath.mock.funcGetCommentPath != nil {
		mmGetCommentPath.mock.t.Fatalf("CommentQueryImpMock.GetCommentPath mock is already set by Set")
	}

	if mmGetCommentPath.defaultExpectation == nil {
		mmGetCommentPath.defaultExpectation = &CommentQueryImpMockGetCommentPathExpectation{}
	}

	if mmGetCommentPath.defaultExpectation.paramPtrs != nil {
		mmGetCommentPath.mock.t.Fatalf("CommentQueryImpMock.GetCommentPath mock is already set by ExpectParams functions")
	}

	mmGetCommentPath.defaultExpectation.params = &CommentQueryImpMockGetCommentPathParams{ctx, parentID}
	mmGetCommentPath.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCommentPath.expectations {
		if minimock.Equal(e.params, mmGetCommentPath.defaultExpectation.params) {
			mmGetCommentPath.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCommentPath.defaultExpectation.params)
		}
	}

	return mmGetCommentPath
}

// ExpectCtxParam1 sets up expected param ctx for CommentQueryImp.GetCommentPath
func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) ExpectCtxParam1(ctx context.Context) *mCommentQueryImpMockGetCommentPath {
	if mmGetCommentPath.mock.funcGetCommentPath != nil {
		mmGetCommentPath.mock.t.Fatalf("CommentQueryImpMock.GetCommentPath mock is already set by Set")
	}

	if mmGetCommentPath.defaultExpectation == nil {
		mmGetCommentPath.defaultExpectation = &CommentQueryImpMockGetCommentPathExpectation{}
	}

	if mmGetCommentPath.defaultExpectation.params != nil {
		mmGetCommentPath.mock.t.Fatalf("CommentQueryImpMock.GetCommentPath mock is already set by Expect")
	}

	if mmGetCommentPath.defaultExpectation.paramPtrs == nil {
		mmGetCommentPath.defaultExpectation.paramPtrs = &CommentQueryImpMockGetCommentPathParamPtrs{}
	}
	mmGetCommentPath.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCommentPath.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCommentPath
}

// ExpectParentIDParam2 sets up expected param parentID for CommentQueryImp.GetCommentPath
func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) ExpectParentIDParam2(parentID int64) *mCommentQueryImpMockGetCommentPath {
	if mmGetCommentPath.mock.funcGetCommentPath != nil {
		mmGetCommentPath.mock.t.Fatalf("CommentQueryImpMock.GetCommentPath mock is already set by Set")
	}

	if mmGetCommentPath.defaultExpectation == nil {
		mmGetCommentPath.defaultExpectation = &CommentQueryImpMockGetCommentPathExpectation{}
	}

	if mmGetCommentPath.defaultExpectation.params != nil {
		mmGetCommentPath.mock.t.Fatalf("CommentQueryImpMock.GetCommentPath mock is already set by Expect")
	}

	if mmGetCommentPath.defaultExpectation.paramPtrs == nil {
		mmGetCommentPath.defaultExpectation.paramPtrs = &CommentQueryImpMockGetCommentPathParamPtrs{}
	}
	mmGetCommentPath.defaultExpectation.paramPtrs.parentID = &parentID
	mmGetCommentPath.defaultExpectation.expectationOrigins.originParentID = minimock.CallerInfo(1)

	return mmGetCommentPath
}

// Inspect accepts an inspector function that has same arguments as the CommentQueryImp.GetCommentPath
func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) Inspect(f func(ctx context.Context, parentID int64)) *mCommentQueryImpMockGetCommentPath {
	if mmGetCommentPath.mock.inspectFuncGetCommentPath != nil {
		mmGetCommentPath.mock.t.Fatalf("Inspect function is already set for CommentQueryImpMock.GetCommentPath")
	}

	mmGetCommentPath.mock.inspectFuncGetCommentPath = f

	return mmGetCommentPath
}

// Return sets up results that will be returned by CommentQueryImp.GetCommentPath
func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) Return(s1 string, err error) *CommentQueryImpMock {
	if mmGetCommentPath.mock.funcGetCommentPath != nil {
		mmGetCommentPath.mock.t.Fatalf("CommentQueryImpMock.GetCommentPath mock is already set by Set")
	}

	if mmGetCommentPath.defaultExpectation == nil {
		mmGetCommentPath.defaultExpectation = &CommentQueryImpMockGetCommentPathExpectation{mock: mmGetCommentPath.mock}
	}
	mmGetCommentPath.defaultExpectation.results = &CommentQueryImpMockGetCommentPathResults{s1, err}
	mmGetCommentPath.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCommentPath.mock
}

// Set uses given function f to mock the CommentQueryImp.GetCommentPath method
func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) Set(f func(ctx context.Context, parentID int64) (s1 string, err error)) *CommentQueryImpMock {
	if mmGetCommentPath.defaultExpectation != nil {
		mmGetCommentPath.mock.t.Fatalf("Default expectation is already set for the CommentQueryImp.GetCommentPath method")
	}

	if len(mmGetCommentPath.expectations) > 0 {
		mmGetCommentPath.mock.t.Fatalf("Some expectations are already set for the CommentQueryImp.GetCommentPath method")
	}

	mmGetCommentPath.mock.funcGetCommentPath = f
	mmGetCommentPath.mock.funcGetCommentPathOrigin = minimock.CallerInfo(1)
	return mmGetCommentPath.mock
}

// When sets expectation for the CommentQueryImp.GetCommentPath which will trigger the result defined by the following
// Then helper
func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) When(ctx context.Context, parentID int64) *CommentQueryImpMockGetCommentPathExpectation {
	if mmGetCommentPath.mock.funcGetCommentPath != nil {
		mmGetCommentPath.mock.t.Fatalf("CommentQueryImpMock.GetCommentPath mock is already set by Set")
	}

	expectation := &CommentQueryImpMockGetCommentPathExpectation{
		mock:               mmGetCommentPath.mock,
		params:             &CommentQueryImpMockGetCommentPathParams{ctx, parentID},
		expectationOrigins: CommentQueryImpMockGetCommentPathExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCommentPath.expectations = append(mmGetCommentPath.expectations, expectation)
	return expectation
}

// Then sets up CommentQueryImp.GetCommentPath return parameters for the expectation previously defined by the When method
func (e *CommentQueryImpMockGetCommentPathExpectation) Then(s1 string, err error) *CommentQueryImpMock {
	e.results = &CommentQueryImpMockGetCommentPathResults{s1, err}
	return e.mock
}

// Times sets number of times CommentQueryImp.GetCommentPath should be invoked
func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) Times(n uint64) *mCommentQueryImpMockGetCommentPath {
	if n == 0 {
		mmGetCommentPath.mock.t.Fatalf("Times of CommentQueryImpMock.GetCommentPath mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCommentPath.expectedInvocations, n)
	mmGetCommentPath.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCommentPath
}

func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) invocationsDone() bool {
	if len(mmGetCommentPath.expectations) == 0 && mmGetCommentPath.defaultExpectation == nil && mmGetCommentPath.mock.funcGetCommentPath == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCommentPath.mock.afterGetCommentPathCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCommentPath.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCommentPath implements CommentQueryImp
func (mmGetCommentPath *CommentQueryImpMock) GetCommentPath(ctx context.Context, parentID int64) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetCommentPath.beforeGetCommentPathCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCommentPath.afterGetCommentPathCounter, 1)

	mmGetCommentPath.t.Helper()

	if mmGetCommentPath.inspectFuncGetCommentPath != nil {
		mmGetCommentPath.inspectFuncGetCommentPath(ctx, parentID)
	}

	mm_params := CommentQueryImpMockGetCommentPathParams{ctx, parentID}

	// Record call args
	mmGetCommentPath.GetCommentPathMock.mutex.Lock()
	mmGetCommentPath.GetCommentPathMock.callArgs = append(mmGetCommentPath.GetCommentPathMock.callArgs, &mm_params)
	mmGetCommentPath.GetCommentPathMock.mutex.Unlock()

	for _, e := range mmGetCommentPath.GetCommentPathMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetCommentPath.GetCommentPathMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCommentPath.GetCommentPathMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCommentPath.GetCommentPathMock.defaultExpectation.params
		mm_want_ptrs := mmGetCommentPath.GetCommentPathMock.defaultExpectation.paramPtrs

		mm_got := CommentQueryImpMockGetCommentPathParams{ctx, parentID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCommentPath.t.Errorf("CommentQueryImpMock.GetCommentPath got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentPath.GetCommentPathMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.parentID != nil && !minimock.Equal(*mm_want_ptrs.parentID, mm_got.parentID) {
				mmGetCommentPath.t.Errorf("CommentQueryImpMock.GetCommentPath got unexpected parameter parentID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentPath.GetCommentPathMock.defaultExpectation.expectationOrigins.originParentID, *mm_want_ptrs.parentID, mm_got.parentID, minimock.Diff(*mm_want_ptrs.parentID, mm_got.parentID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCommentPath.t.Errorf("CommentQueryImpMock.GetCommentPath got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCommentPath.GetCommentPathMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCommentPath.GetCommentPathMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCommentPath.t.Fatal("No results are set for the CommentQueryImpMock.GetCommentPath")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetCommentPath.funcGetCommentPath != nil {
		return mmGetCommentPath.funcGetCommentPath(ctx, parentID)
	}
	mmGetCommentPath.t.Fatalf("Unexpected call to CommentQueryImpMock.GetCommentPath. %v %v", ctx, parentID)
	return
}

// GetCommentPathAfterCounter returns a count of finished CommentQueryImpMock.GetCommentPath invocations
func (mmGetCommentPath *CommentQueryImpMock) GetCommentPathAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentPath.afterGetCommentPathCounter)
}

// GetCommentPathBeforeCounter returns a count of CommentQueryImpMock.GetCommentPath invocations
func (mmGetCommentPath *CommentQueryImpMock) GetCommentPathBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentPath.beforeGetCommentPathCounter)
}

// Calls returns a list of arguments used in each call to CommentQueryImpMock.GetCommentPath.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCommentPath *mCommentQueryImpMockGetCommentPath) Calls() []*CommentQueryImpMockGetCommentPathParams {
	mmGetCommentPath.mutex.RLock()

	argCopy := make([]*CommentQueryImpMockGetCommentPathParams, len(mmGetCommentPath.callArgs))
	copy(argCopy, mmGetCommentPath.callArgs)

	mmGetCommentPath.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentPathDone returns true if the count of the GetCommentPath invocations corresponds
// the number of defined expectations
func (m *CommentQueryImpMock) MinimockGetCommentPathDone() bool {
	if m.GetCommentPathMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCommentPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommentPathMock.invocationsDone()
}

// MinimockGetCommentPathInspect logs each unmet expectation
func (m *CommentQueryImpMock) MinimockGetCommentPathInspect() {
	for _, e := range m.GetCommentPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentQueryImpMock.GetCommentPath at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCommentPathCounter := mm_atomic.LoadUint64(&m.afterGetCommentPathCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentPathMock.defaultExpectation != nil && afterGetCommentPathCounter < 1 {
		if m.GetCommentPathMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentQueryImpMock.GetCommentPath at\n%s", m.GetCommentPathMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentQueryImpMock.GetCommentPath at\n%s with params: %#v", m.GetCommentPathMock.defaultExpectation.expectationOrigins.origin, *m.GetCommentPathMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCommentPath != nil && afterGetCommentPathCounter < 1 {
		m.t.Errorf("Expected call to CommentQueryImpMock.GetCommentPath at\n%s", m.funcGetCommentPathOrigin)
	}

	if !m.GetCommentPathMock.invocationsDone() && afterGetCommentPathCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentQueryImpMock.GetCommentPath at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommentPathMock.expectedInvocations), m.GetCommentPathMock.expectedInvocationsOrigin, afterGetCommentPathCounter)
	}
}

type mCommentQueryImpMockGetCommentsBranch struct {
	optional           bool
	mock               *CommentQueryImpMock
	defaultExpectation *CommentQueryImpMockGetCommentsBranchExpectation
	expectations       []*CommentQueryImpMockGetCommentsBranchExpectation

	callArgs []*CommentQueryImpMockGetCommentsBranchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentQueryImpMockGetCommentsBranchExpectation specifies expectation struct of the CommentQueryImp.GetCommentsBranch
type CommentQueryImpMockGetCommentsBranchExpectation struct {
	mock               *CommentQueryImpMock
	params             *CommentQueryImpMockGetCommentsBranchParams
	paramPtrs          *CommentQueryImpMockGetCommentsBranchParamPtrs
	expectationOrigins CommentQueryImpMockGetCommentsBranchExpectationOrigins
	results            *CommentQueryImpMockGetCommentsBranchResults
	returnOrigin       string
	Counter            uint64
}

// CommentQueryImpMockGetCommentsBranchParams contains parameters of the CommentQueryImp.GetCommentsBranch
type CommentQueryImpMockGetCommentsBranchParams struct {
	ctx    context.Context
	postID int64
	path   string
}

// CommentQueryImpMockGetCommentsBranchParamPtrs contains pointers to parameters of the CommentQueryImp.GetCommentsBranch
type CommentQueryImpMockGetCommentsBranchParamPtrs struct {
	ctx    *context.Context
	postID *int64
	path   *string
}

// CommentQueryImpMockGetCommentsBranchResults contains results of the CommentQueryImp.GetCommentsBranch
type CommentQueryImpMockGetCommentsBranchResults struct {
	cpa1 []*model.Comment
	err  error
}

// CommentQueryImpMockGetCommentsBranchOrigins contains origins of expectations of the CommentQueryImp.GetCommentsBranch
type CommentQueryImpMockGetCommentsBranchExpectationOrigins struct {
	origin       string
	originCtx    string
	originPostID string
	originPath   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) Optional() *mCommentQueryImpMockGetCommentsBranch {
	mmGetCommentsBranch.optional = true
	return mmGetCommentsBranch
}

// Expect sets up expected params for CommentQueryImp.GetCommentsBranch
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) Expect(ctx context.Context, postID int64, path string) *mCommentQueryImpMockGetCommentsBranch {
	if mmGetCommentsBranch.mock.funcGetCommentsBranch != nil {
		mmGetCommentsBranch.mock.t.Fatalf("CommentQueryImpMock.GetCommentsBranch mock is already set by Set")
	}

	if mmGetCommentsBranch.defaultExpectation == nil {
		mmGetCommentsBranch.defaultExpectation = &CommentQueryImpMockGetCommentsBranchExpectation{}
	}

	if mmGetCommentsBranch.defaultExpectation.paramPtrs != nil {
		mmGetCommentsBranch.mock.t.Fatalf("CommentQueryImpMock.GetCommentsBranch mock is already set by ExpectParams functions")
	}

	mmGetCommentsBranch.defaultExpectation.params = &CommentQueryImpMockGetCommentsBranchParams{ctx, postID, path}
	mmGetCommentsBranch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCommentsBranch.expectations {
		if minimock.Equal(e.params, mmGetCommentsBranch.defaultExpectation.params) {
			mmGetCommentsBranch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCommentsBranch.defaultExpectation.params)
		}
	}

	return mmGetCommentsBranch
}

// ExpectCtxParam1 sets up expected param ctx for CommentQueryImp.GetCommentsBranch
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) ExpectCtxParam1(ctx context.Context) *mCommentQueryImpMockGetCommentsBranch {
	if mmGetCommentsBranch.mock.funcGetCommentsBranch != nil {
		mmGetCommentsBranch.mock.t.Fatalf("CommentQueryImpMock.GetCommentsBranch mock is already set by Set")
	}

	if mmGetCommentsBranch.defaultExpectation == nil {
		mmGetCommentsBranch.defaultExpectation = &CommentQueryImpMockGetCommentsBranchExpectation{}
	}

	if mmGetCommentsBranch.defaultExpectation.params != nil {
		mmGetCommentsBranch.mock.t.Fatalf("CommentQueryImpMock.GetCommentsBranch mock is already set by Expect")
	}

	if mmGetCommentsBranch.defaultExpectation.paramPtrs == nil {
		mmGetCommentsBranch.defaultExpectation.paramPtrs = &CommentQueryImpMockGetCommentsBranchParamPtrs{}
	}
	mmGetCommentsBranch.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCommentsBranch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCommentsBranch
}

// ExpectPostIDParam2 sets up expected param postID for CommentQueryImp.GetCommentsBranch
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) ExpectPostIDParam2(postID int64) *mCommentQueryImpMockGetCommentsBranch {
	if mmGetCommentsBranch.mock.funcGetCommentsBranch != nil {
		mmGetCommentsBranch.mock.t.Fatalf("CommentQueryImpMock.GetCommentsBranch mock is already set by Set")
	}

	if mmGetCommentsBranch.defaultExpectation == nil {
		mmGetCommentsBranch.defaultExpectation = &CommentQueryImpMockGetCommentsBranchExpectation{}
	}

	if mmGetCommentsBranch.defaultExpectation.params != nil {
		mmGetCommentsBranch.mock.t.Fatalf("CommentQueryImpMock.GetCommentsBranch mock is already set by Expect")
	}

	if mmGetCommentsBranch.defaultExpectation.paramPtrs == nil {
		mmGetCommentsBranch.defaultExpectation.paramPtrs = &CommentQueryImpMockGetCommentsBranchParamPtrs{}
	}
	mmGetCommentsBranch.defaultExpectation.paramPtrs.postID = &postID
	mmGetCommentsBranch.defaultExpectation.expectationOrigins.originPostID = minimock.CallerInfo(1)

	return mmGetCommentsBranch
}

// ExpectPathParam3 sets up expected param path for CommentQueryImp.GetCommentsBranch
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) ExpectPathParam3(path string) *mCommentQueryImpMockGetCommentsBranch {
	if mmGetCommentsBranch.mock.funcGetCommentsBranch != nil {
		mmGetCommentsBranch.mock.t.Fatalf("CommentQueryImpMock.GetCommentsBranch mock is already set by Set")
	}

	if mmGetCommentsBranch.defaultExpectation == nil {
		mmGetCommentsBranch.defaultExpectation = &CommentQueryImpMockGetCommentsBranchExpectation{}
	}

	if mmGetCommentsBranch.defaultExpectation.params != nil {
		mmGetCommentsBranch.mock.t.Fatalf("CommentQueryImpMock.GetCommentsBranch mock is already set by Expect")
	}

	if mmGetCommentsBranch.defaultExpectation.paramPtrs == nil {
		mmGetCommentsBranch.defaultExpectation.paramPtrs = &CommentQueryImpMockGetCommentsBranchParamPtrs{}
	}
	mmGetCommentsBranch.defaultExpectation.paramPtrs.path = &path
	mmGetCommentsBranch.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmGetCommentsBranch
}

// Inspect accepts an inspector function that has same arguments as the CommentQueryImp.GetCommentsBranch
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) Inspect(f func(ctx context.Context, postID int64, path string)) *mCommentQueryImpMockGetCommentsBranch {
	if mmGetCommentsBranch.mock.inspectFuncGetCommentsBranch != nil {
		mmGetCommentsBranch.mock.t.Fatalf("Inspect function is already set for CommentQueryImpMock.GetCommentsBranch")
	}

	mmGetCommentsBranch.mock.inspectFuncGetCommentsBranch = f

	return mmGetCommentsBranch
}

// Return sets up results that will be returned by CommentQueryImp.GetCommentsBranch
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) Return(cpa1 []*model.Comment, err error) *CommentQueryImpMock {
	if mmGetCommentsBranch.mock.funcGetCommentsBranch != nil {
		mmGetCommentsBranch.mock.t.Fatalf("CommentQueryImpMock.GetCommentsBranch mock is already set by Set")
	}

	if mmGetCommentsBranch.defaultExpectation == nil {
		mmGetCommentsBranch.defaultExpectation = &CommentQueryImpMockGetCommentsBranchExpectation{mock: mmGetCommentsBranch.mock}
	}
	mmGetCommentsBranch.defaultExpectation.results = &CommentQueryImpMockGetCommentsBranchResults{cpa1, err}
	mmGetCommentsBranch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCommentsBranch.mock
}

// Set uses given function f to mock the CommentQueryImp.GetCommentsBranch method
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) Set(f func(ctx context.Context, postID int64, path string) (cpa1 []*model.Comment, err error)) *CommentQueryImpMock {
	if mmGetCommentsBranch.defaultExpectation != nil {
		mmGetCommentsBranch.mock.t.Fatalf("Default expectation is already set for the CommentQueryImp.GetCommentsBranch method")
	}

	if len(mmGetCommentsBranch.expectations) > 0 {
		mmGetCommentsBranch.mock.t.Fatalf("Some expectations are already set for the CommentQueryImp.GetCommentsBranch method")
	}

	mmGetCommentsBranch.mock.funcGetCommentsBranch = f
	mmGetCommentsBranch.mock.funcGetCommentsBranchOrigin = minimock.CallerInfo(1)
	return mmGetCommentsBranch.mock
}

// When sets expectation for the CommentQueryImp.GetCommentsBranch which will trigger the result defined by the following
// Then helper
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) When(ctx context.Context, postID int64, path string) *CommentQueryImpMockGetCommentsBranchExpectation {
	if mmGetCommentsBranch.mock.funcGetCommentsBranch != nil {
		mmGetCommentsBranch.mock.t.Fatalf("CommentQueryImpMock.GetCommentsBranch mock is already set by Set")
	}

	expectation := &CommentQueryImpMockGetCommentsBranchExpectation{
		mock:               mmGetCommentsBranch.mock,
		params:             &CommentQueryImpMockGetCommentsBranchParams{ctx, postID, path},
		expectationOrigins: CommentQueryImpMockGetCommentsBranchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCommentsBranch.expectations = append(mmGetCommentsBranch.expectations, expectation)
	return expectation
}

// Then sets up CommentQueryImp.GetCommentsBranch return parameters for the expectation previously defined by the When method
func (e *CommentQueryImpMockGetCommentsBranchExpectation) Then(cpa1 []*model.Comment, err error) *CommentQueryImpMock {
	e.results = &CommentQueryImpMockGetCommentsBranchResults{cpa1, err}
	return e.mock
}

// Times sets number of times CommentQueryImp.GetCommentsBranch should be invoked
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) Times(n uint64) *mCommentQueryImpMockGetCommentsBranch {
	if n == 0 {
		mmGetCommentsBranch.mock.t.Fatalf("Times of CommentQueryImpMock.GetCommentsBranch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCommentsBranch.expectedInvocations, n)
	mmGetCommentsBranch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCommentsBranch
}

func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) invocationsDone() bool {
	if len(mmGetCommentsBranch.expectations) == 0 && mmGetCommentsBranch.defaultExpectation == nil && mmGetCommentsBranch.mock.funcGetCommentsBranch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCommentsBranch.mock.afterGetCommentsBranchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCommentsBranch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCommentsBranch implements CommentQueryImp
func (mmGetCommentsBranch *CommentQueryImpMock) GetCommentsBranch(ctx context.Context, postID int64, path string) (cpa1 []*model.Comment, err error) {
	mm_atomic.AddUint64(&mmGetCommentsBranch.beforeGetCommentsBranchCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCommentsBranch.afterGetCommentsBranchCounter, 1)

	mmGetCommentsBranch.t.Helper()

	if mmGetCommentsBranch.inspectFuncGetCommentsBranch != nil {
		mmGetCommentsBranch.inspectFuncGetCommentsBranch(ctx, postID, path)
	}

	mm_params := CommentQueryImpMockGetCommentsBranchParams{ctx, postID, path}

	// Record call args
	mmGetCommentsBranch.GetCommentsBranchMock.mutex.Lock()
	mmGetCommentsBranch.GetCommentsBranchMock.callArgs = append(mmGetCommentsBranch.GetCommentsBranchMock.callArgs, &mm_params)
	mmGetCommentsBranch.GetCommentsBranchMock.mutex.Unlock()

	for _, e := range mmGetCommentsBranch.GetCommentsBranchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetCommentsBranch.GetCommentsBranchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCommentsBranch.GetCommentsBranchMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCommentsBranch.GetCommentsBranchMock.defaultExpectation.params
		mm_want_ptrs := mmGetCommentsBranch.GetCommentsBranchMock.defaultExpectation.paramPtrs

		mm_got := CommentQueryImpMockGetCommentsBranchParams{ctx, postID, path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCommentsBranch.t.Errorf("CommentQueryImpMock.GetCommentsBranch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsBranch.GetCommentsBranchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmGetCommentsBranch.t.Errorf("CommentQueryImpMock.GetCommentsBranch got unexpected parameter postID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsBranch.GetCommentsBranchMock.defaultExpectation.expectationOrigins.originPostID, *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmGetCommentsBranch.t.Errorf("CommentQueryImpMock.GetCommentsBranch got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsBranch.GetCommentsBranchMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCommentsBranch.t.Errorf("CommentQueryImpMock.GetCommentsBranch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCommentsBranch.GetCommentsBranchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCommentsBranch.GetCommentsBranchMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCommentsBranch.t.Fatal("No results are set for the CommentQueryImpMock.GetCommentsBranch")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetCommentsBranch.funcGetCommentsBranch != nil {
		return mmGetCommentsBranch.funcGetCommentsBranch(ctx, postID, path)
	}
	mmGetCommentsBranch.t.Fatalf("Unexpected call to CommentQueryImpMock.GetCommentsBranch. %v %v %v", ctx, postID, path)
	return
}

// GetCommentsBranchAfterCounter returns a count of finished CommentQueryImpMock.GetCommentsBranch invocations
func (mmGetCommentsBranch *CommentQueryImpMock) GetCommentsBranchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsBranch.afterGetCommentsBranchCounter)
}

// GetCommentsBranchBeforeCounter returns a count of CommentQueryImpMock.GetCommentsBranch invocations
func (mmGetCommentsBranch *CommentQueryImpMock) GetCommentsBranchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsBranch.beforeGetCommentsBranchCounter)
}

// Calls returns a list of arguments used in each call to CommentQueryImpMock.GetCommentsBranch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCommentsBranch *mCommentQueryImpMockGetCommentsBranch) Calls() []*CommentQueryImpMockGetCommentsBranchParams {
	mmGetCommentsBranch.mutex.RLock()

	argCopy := make([]*CommentQueryImpMockGetCommentsBranchParams, len(mmGetCommentsBranch.callArgs))
	copy(argCopy, mmGetCommentsBranch.callArgs)

	mmGetCommentsBranch.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentsBranchDone returns true if the count of the GetCommentsBranch invocations corresponds
// the number of defined expectations
func (m *CommentQueryImpMock) MinimockGetCommentsBranchDone() bool {
	if m.GetCommentsBranchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCommentsBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommentsBranchMock.invocationsDone()
}

// MinimockGetCommentsBranchInspect logs each unmet expectation
func (m *CommentQueryImpMock) MinimockGetCommentsBranchInspect() {
	for _, e := range m.GetCommentsBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentQueryImpMock.GetCommentsBranch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCommentsBranchCounter := mm_atomic.LoadUint64(&m.afterGetCommentsBranchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentsBranchMock.defaultExpectation != nil && afterGetCommentsBranchCounter < 1 {
		if m.GetCommentsBranchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentQueryImpMock.GetCommentsBranch at\n%s", m.GetCommentsBranchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentQueryImpMock.GetCommentsBranch at\n%s with params: %#v", m.GetCommentsBranchMock.defaultExpectation.expectationOrigins.origin, *m.GetCommentsBranchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCommentsBranch != nil && afterGetCommentsBranchCounter < 1 {
		m.t.Errorf("Expected call to CommentQueryImpMock.GetCommentsBranch at\n%s", m.funcGetCommentsBranchOrigin)
	}

	if !m.GetCommentsBranchMock.invocationsDone() && afterGetCommentsBranchCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentQueryImpMock.GetCommentsBranch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommentsBranchMock.expectedInvocations), m.GetCommentsBranchMock.expectedInvocationsOrigin, afterGetCommentsBranchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CommentQueryImpMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetCommentPathInspect()

			m.MinimockGetCommentsBranchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CommentQueryImpMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CommentQueryImpMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCommentPathDone() &&
		m.MinimockGetCommentsBranchDone()
}
