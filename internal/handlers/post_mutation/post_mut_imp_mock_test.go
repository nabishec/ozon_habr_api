// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package postmutation

//go:generate minimock -i github.com/nabishec/ozon_habr_api/internal/handlers/post_mutation.PostMutImp -o post_mut_imp_mock_test.go -n PostMutImpMock -p postmutation

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"github.com/nabishec/ozon_habr_api/internal/model"
)

// PostMutImpMock implements PostMutImp
type PostMutImpMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddPost          func(ctx context.Context, newPost *model.NewPost) (pp1 *model.Post, err error)
	funcAddPostOrigin    string
	inspectFuncAddPost   func(ctx context.Context, newPost *model.NewPost)
	afterAddPostCounter  uint64
	beforeAddPostCounter uint64
	AddPostMock          mPostMutImpMockAddPost

	funcUpdateEnableCommentToPost          func(ctx context.Context, postID int64, authorID uuid.UUID, commentsEnabled bool) (pp1 *model.Post, err error)
	funcUpdateEnableCommentToPostOrigin    string
	inspectFuncUpdateEnableCommentToPost   func(ctx context.Context, postID int64, authorID uuid.UUID, commentsEnabled bool)
	afterUpdateEnableCommentToPostCounter  uint64
	beforeUpdateEnableCommentToPostCounter uint64
	UpdateEnableCommentToPostMock          mPostMutImpMockUpdateEnableCommentToPost
}

// NewPostMutImpMock returns a mock for PostMutImp
func NewPostMutImpMock(t minimock.Tester) *PostMutImpMock {
	m := &PostMutImpMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddPostMock = mPostMutImpMockAddPost{mock: m}
	m.AddPostMock.callArgs = []*PostMutImpMockAddPostParams{}

	m.UpdateEnableCommentToPostMock = mPostMutImpMockUpdateEnableCommentToPost{mock: m}
	m.UpdateEnableCommentToPostMock.callArgs = []*PostMutImpMockUpdateEnableCommentToPostParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPostMutImpMockAddPost struct {
	optional           bool
	mock               *PostMutImpMock
	defaultExpectation *PostMutImpMockAddPostExpectation
	expectations       []*PostMutImpMockAddPostExpectation

	callArgs []*PostMutImpMockAddPostParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostMutImpMockAddPostExpectation specifies expectation struct of the PostMutImp.AddPost
type PostMutImpMockAddPostExpectation struct {
	mock               *PostMutImpMock
	params             *PostMutImpMockAddPostParams
	paramPtrs          *PostMutImpMockAddPostParamPtrs
	expectationOrigins PostMutImpMockAddPostExpectationOrigins
	results            *PostMutImpMockAddPostResults
	returnOrigin       string
	Counter            uint64
}

// PostMutImpMockAddPostParams contains parameters of the PostMutImp.AddPost
type PostMutImpMockAddPostParams struct {
	ctx     context.Context
	newPost *model.NewPost
}

// PostMutImpMockAddPostParamPtrs contains pointers to parameters of the PostMutImp.AddPost
type PostMutImpMockAddPostParamPtrs struct {
	ctx     *context.Context
	newPost **model.NewPost
}

// PostMutImpMockAddPostResults contains results of the PostMutImp.AddPost
type PostMutImpMockAddPostResults struct {
	pp1 *model.Post
	err error
}

// PostMutImpMockAddPostOrigins contains origins of expectations of the PostMutImp.AddPost
type PostMutImpMockAddPostExpectationOrigins struct {
	origin        string
	originCtx     string
	originNewPost string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPost *mPostMutImpMockAddPost) Optional() *mPostMutImpMockAddPost {
	mmAddPost.optional = true
	return mmAddPost
}

// Expect sets up expected params for PostMutImp.AddPost
func (mmAddPost *mPostMutImpMockAddPost) Expect(ctx context.Context, newPost *model.NewPost) *mPostMutImpMockAddPost {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostMutImpMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostMutImpMockAddPostExpectation{}
	}

	if mmAddPost.defaultExpectation.paramPtrs != nil {
		mmAddPost.mock.t.Fatalf("PostMutImpMock.AddPost mock is already set by ExpectParams functions")
	}

	mmAddPost.defaultExpectation.params = &PostMutImpMockAddPostParams{ctx, newPost}
	mmAddPost.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddPost.expectations {
		if minimock.Equal(e.params, mmAddPost.defaultExpectation.params) {
			mmAddPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPost.defaultExpectation.params)
		}
	}

	return mmAddPost
}

// ExpectCtxParam1 sets up expected param ctx for PostMutImp.AddPost
func (mmAddPost *mPostMutImpMockAddPost) ExpectCtxParam1(ctx context.Context) *mPostMutImpMockAddPost {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostMutImpMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostMutImpMockAddPostExpectation{}
	}

	if mmAddPost.defaultExpectation.params != nil {
		mmAddPost.mock.t.Fatalf("PostMutImpMock.AddPost mock is already set by Expect")
	}

	if mmAddPost.defaultExpectation.paramPtrs == nil {
		mmAddPost.defaultExpectation.paramPtrs = &PostMutImpMockAddPostParamPtrs{}
	}
	mmAddPost.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddPost.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddPost
}

// ExpectNewPostParam2 sets up expected param newPost for PostMutImp.AddPost
func (mmAddPost *mPostMutImpMockAddPost) ExpectNewPostParam2(newPost *model.NewPost) *mPostMutImpMockAddPost {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostMutImpMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostMutImpMockAddPostExpectation{}
	}

	if mmAddPost.defaultExpectation.params != nil {
		mmAddPost.mock.t.Fatalf("PostMutImpMock.AddPost mock is already set by Expect")
	}

	if mmAddPost.defaultExpectation.paramPtrs == nil {
		mmAddPost.defaultExpectation.paramPtrs = &PostMutImpMockAddPostParamPtrs{}
	}
	mmAddPost.defaultExpectation.paramPtrs.newPost = &newPost
	mmAddPost.defaultExpectation.expectationOrigins.originNewPost = minimock.CallerInfo(1)

	return mmAddPost
}

// Inspect accepts an inspector function that has same arguments as the PostMutImp.AddPost
func (mmAddPost *mPostMutImpMockAddPost) Inspect(f func(ctx context.Context, newPost *model.NewPost)) *mPostMutImpMockAddPost {
	if mmAddPost.mock.inspectFuncAddPost != nil {
		mmAddPost.mock.t.Fatalf("Inspect function is already set for PostMutImpMock.AddPost")
	}

	mmAddPost.mock.inspectFuncAddPost = f

	return mmAddPost
}

// Return sets up results that will be returned by PostMutImp.AddPost
func (mmAddPost *mPostMutImpMockAddPost) Return(pp1 *model.Post, err error) *PostMutImpMock {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostMutImpMock.AddPost mock is already set by Set")
	}

	if mmAddPost.defaultExpectation == nil {
		mmAddPost.defaultExpectation = &PostMutImpMockAddPostExpectation{mock: mmAddPost.mock}
	}
	mmAddPost.defaultExpectation.results = &PostMutImpMockAddPostResults{pp1, err}
	mmAddPost.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddPost.mock
}

// Set uses given function f to mock the PostMutImp.AddPost method
func (mmAddPost *mPostMutImpMockAddPost) Set(f func(ctx context.Context, newPost *model.NewPost) (pp1 *model.Post, err error)) *PostMutImpMock {
	if mmAddPost.defaultExpectation != nil {
		mmAddPost.mock.t.Fatalf("Default expectation is already set for the PostMutImp.AddPost method")
	}

	if len(mmAddPost.expectations) > 0 {
		mmAddPost.mock.t.Fatalf("Some expectations are already set for the PostMutImp.AddPost method")
	}

	mmAddPost.mock.funcAddPost = f
	mmAddPost.mock.funcAddPostOrigin = minimock.CallerInfo(1)
	return mmAddPost.mock
}

// When sets expectation for the PostMutImp.AddPost which will trigger the result defined by the following
// Then helper
func (mmAddPost *mPostMutImpMockAddPost) When(ctx context.Context, newPost *model.NewPost) *PostMutImpMockAddPostExpectation {
	if mmAddPost.mock.funcAddPost != nil {
		mmAddPost.mock.t.Fatalf("PostMutImpMock.AddPost mock is already set by Set")
	}

	expectation := &PostMutImpMockAddPostExpectation{
		mock:               mmAddPost.mock,
		params:             &PostMutImpMockAddPostParams{ctx, newPost},
		expectationOrigins: PostMutImpMockAddPostExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddPost.expectations = append(mmAddPost.expectations, expectation)
	return expectation
}

// Then sets up PostMutImp.AddPost return parameters for the expectation previously defined by the When method
func (e *PostMutImpMockAddPostExpectation) Then(pp1 *model.Post, err error) *PostMutImpMock {
	e.results = &PostMutImpMockAddPostResults{pp1, err}
	return e.mock
}

// Times sets number of times PostMutImp.AddPost should be invoked
func (mmAddPost *mPostMutImpMockAddPost) Times(n uint64) *mPostMutImpMockAddPost {
	if n == 0 {
		mmAddPost.mock.t.Fatalf("Times of PostMutImpMock.AddPost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPost.expectedInvocations, n)
	mmAddPost.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddPost
}

func (mmAddPost *mPostMutImpMockAddPost) invocationsDone() bool {
	if len(mmAddPost.expectations) == 0 && mmAddPost.defaultExpectation == nil && mmAddPost.mock.funcAddPost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPost.mock.afterAddPostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPost implements PostMutImp
func (mmAddPost *PostMutImpMock) AddPost(ctx context.Context, newPost *model.NewPost) (pp1 *model.Post, err error) {
	mm_atomic.AddUint64(&mmAddPost.beforeAddPostCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPost.afterAddPostCounter, 1)

	mmAddPost.t.Helper()

	if mmAddPost.inspectFuncAddPost != nil {
		mmAddPost.inspectFuncAddPost(ctx, newPost)
	}

	mm_params := PostMutImpMockAddPostParams{ctx, newPost}

	// Record call args
	mmAddPost.AddPostMock.mutex.Lock()
	mmAddPost.AddPostMock.callArgs = append(mmAddPost.AddPostMock.callArgs, &mm_params)
	mmAddPost.AddPostMock.mutex.Unlock()

	for _, e := range mmAddPost.AddPostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmAddPost.AddPostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPost.AddPostMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPost.AddPostMock.defaultExpectation.params
		mm_want_ptrs := mmAddPost.AddPostMock.defaultExpectation.paramPtrs

		mm_got := PostMutImpMockAddPostParams{ctx, newPost}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddPost.t.Errorf("PostMutImpMock.AddPost got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPost.AddPostMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.newPost != nil && !minimock.Equal(*mm_want_ptrs.newPost, mm_got.newPost) {
				mmAddPost.t.Errorf("PostMutImpMock.AddPost got unexpected parameter newPost, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPost.AddPostMock.defaultExpectation.expectationOrigins.originNewPost, *mm_want_ptrs.newPost, mm_got.newPost, minimock.Diff(*mm_want_ptrs.newPost, mm_got.newPost))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPost.t.Errorf("PostMutImpMock.AddPost got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddPost.AddPostMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPost.AddPostMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPost.t.Fatal("No results are set for the PostMutImpMock.AddPost")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmAddPost.funcAddPost != nil {
		return mmAddPost.funcAddPost(ctx, newPost)
	}
	mmAddPost.t.Fatalf("Unexpected call to PostMutImpMock.AddPost. %v %v", ctx, newPost)
	return
}

// AddPostAfterCounter returns a count of finished PostMutImpMock.AddPost invocations
func (mmAddPost *PostMutImpMock) AddPostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPost.afterAddPostCounter)
}

// AddPostBeforeCounter returns a count of PostMutImpMock.AddPost invocations
func (mmAddPost *PostMutImpMock) AddPostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPost.beforeAddPostCounter)
}

// Calls returns a list of arguments used in each call to PostMutImpMock.AddPost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPost *mPostMutImpMockAddPost) Calls() []*PostMutImpMockAddPostParams {
	mmAddPost.mutex.RLock()

	argCopy := make([]*PostMutImpMockAddPostParams, len(mmAddPost.callArgs))
	copy(argCopy, mmAddPost.callArgs)

	mmAddPost.mutex.RUnlock()

	return argCopy
}

// MinimockAddPostDone returns true if the count of the AddPost invocations corresponds
// the number of defined expectations
func (m *PostMutImpMock) MinimockAddPostDone() bool {
	if m.AddPostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPostMock.invocationsDone()
}

// MinimockAddPostInspect logs each unmet expectation
func (m *PostMutImpMock) MinimockAddPostInspect() {
	for _, e := range m.AddPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostMutImpMock.AddPost at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddPostCounter := mm_atomic.LoadUint64(&m.afterAddPostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPostMock.defaultExpectation != nil && afterAddPostCounter < 1 {
		if m.AddPostMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostMutImpMock.AddPost at\n%s", m.AddPostMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostMutImpMock.AddPost at\n%s with params: %#v", m.AddPostMock.defaultExpectation.expectationOrigins.origin, *m.AddPostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPost != nil && afterAddPostCounter < 1 {
		m.t.Errorf("Expected call to PostMutImpMock.AddPost at\n%s", m.funcAddPostOrigin)
	}

	if !m.AddPostMock.invocationsDone() && afterAddPostCounter > 0 {
		m.t.Errorf("Expected %d calls to PostMutImpMock.AddPost at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddPostMock.expectedInvocations), m.AddPostMock.expectedInvocationsOrigin, afterAddPostCounter)
	}
}

type mPostMutImpMockUpdateEnableCommentToPost struct {
	optional           bool
	mock               *PostMutImpMock
	defaultExpectation *PostMutImpMockUpdateEnableCommentToPostExpectation
	expectations       []*PostMutImpMockUpdateEnableCommentToPostExpectation

	callArgs []*PostMutImpMockUpdateEnableCommentToPostParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostMutImpMockUpdateEnableCommentToPostExpectation specifies expectation struct of the PostMutImp.UpdateEnableCommentToPost
type PostMutImpMockUpdateEnableCommentToPostExpectation struct {
	mock               *PostMutImpMock
	params             *PostMutImpMockUpdateEnableCommentToPostParams
	paramPtrs          *PostMutImpMockUpdateEnableCommentToPostParamPtrs
	expectationOrigins PostMutImpMockUpdateEnableCommentToPostExpectationOrigins
	results            *PostMutImpMockUpdateEnableCommentToPostResults
	returnOrigin       string
	Counter            uint64
}

// PostMutImpMockUpdateEnableCommentToPostParams contains parameters of the PostMutImp.UpdateEnableCommentToPost
type PostMutImpMockUpdateEnableCommentToPostParams struct {
	ctx             context.Context
	postID          int64
	authorID        uuid.UUID
	commentsEnabled bool
}

// PostMutImpMockUpdateEnableCommentToPostParamPtrs contains pointers to parameters of the PostMutImp.UpdateEnableCommentToPost
type PostMutImpMockUpdateEnableCommentToPostParamPtrs struct {
	ctx             *context.Context
	postID          *int64
	authorID        *uuid.UUID
	commentsEnabled *bool
}

// PostMutImpMockUpdateEnableCommentToPostResults contains results of the PostMutImp.UpdateEnableCommentToPost
type PostMutImpMockUpdateEnableCommentToPostResults struct {
	pp1 *model.Post
	err error
}

// PostMutImpMockUpdateEnableCommentToPostOrigins contains origins of expectations of the PostMutImp.UpdateEnableCommentToPost
type PostMutImpMockUpdateEnableCommentToPostExpectationOrigins struct {
	origin                string
	originCtx             string
	originPostID          string
	originAuthorID        string
	originCommentsEnabled string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) Optional() *mPostMutImpMockUpdateEnableCommentToPost {
	mmUpdateEnableCommentToPost.optional = true
	return mmUpdateEnableCommentToPost
}

// Expect sets up expected params for PostMutImp.UpdateEnableCommentToPost
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) Expect(ctx context.Context, postID int64, authorID uuid.UUID, commentsEnabled bool) *mPostMutImpMockUpdateEnableCommentToPost {
	if mmUpdateEnableCommentToPost.mock.funcUpdateEnableCommentToPost != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Set")
	}

	if mmUpdateEnableCommentToPost.defaultExpectation == nil {
		mmUpdateEnableCommentToPost.defaultExpectation = &PostMutImpMockUpdateEnableCommentToPostExpectation{}
	}

	if mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by ExpectParams functions")
	}

	mmUpdateEnableCommentToPost.defaultExpectation.params = &PostMutImpMockUpdateEnableCommentToPostParams{ctx, postID, authorID, commentsEnabled}
	mmUpdateEnableCommentToPost.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateEnableCommentToPost.expectations {
		if minimock.Equal(e.params, mmUpdateEnableCommentToPost.defaultExpectation.params) {
			mmUpdateEnableCommentToPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateEnableCommentToPost.defaultExpectation.params)
		}
	}

	return mmUpdateEnableCommentToPost
}

// ExpectCtxParam1 sets up expected param ctx for PostMutImp.UpdateEnableCommentToPost
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) ExpectCtxParam1(ctx context.Context) *mPostMutImpMockUpdateEnableCommentToPost {
	if mmUpdateEnableCommentToPost.mock.funcUpdateEnableCommentToPost != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Set")
	}

	if mmUpdateEnableCommentToPost.defaultExpectation == nil {
		mmUpdateEnableCommentToPost.defaultExpectation = &PostMutImpMockUpdateEnableCommentToPostExpectation{}
	}

	if mmUpdateEnableCommentToPost.defaultExpectation.params != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Expect")
	}

	if mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs == nil {
		mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs = &PostMutImpMockUpdateEnableCommentToPostParamPtrs{}
	}
	mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateEnableCommentToPost.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateEnableCommentToPost
}

// ExpectPostIDParam2 sets up expected param postID for PostMutImp.UpdateEnableCommentToPost
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) ExpectPostIDParam2(postID int64) *mPostMutImpMockUpdateEnableCommentToPost {
	if mmUpdateEnableCommentToPost.mock.funcUpdateEnableCommentToPost != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Set")
	}

	if mmUpdateEnableCommentToPost.defaultExpectation == nil {
		mmUpdateEnableCommentToPost.defaultExpectation = &PostMutImpMockUpdateEnableCommentToPostExpectation{}
	}

	if mmUpdateEnableCommentToPost.defaultExpectation.params != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Expect")
	}

	if mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs == nil {
		mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs = &PostMutImpMockUpdateEnableCommentToPostParamPtrs{}
	}
	mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs.postID = &postID
	mmUpdateEnableCommentToPost.defaultExpectation.expectationOrigins.originPostID = minimock.CallerInfo(1)

	return mmUpdateEnableCommentToPost
}

// ExpectAuthorIDParam3 sets up expected param authorID for PostMutImp.UpdateEnableCommentToPost
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) ExpectAuthorIDParam3(authorID uuid.UUID) *mPostMutImpMockUpdateEnableCommentToPost {
	if mmUpdateEnableCommentToPost.mock.funcUpdateEnableCommentToPost != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Set")
	}

	if mmUpdateEnableCommentToPost.defaultExpectation == nil {
		mmUpdateEnableCommentToPost.defaultExpectation = &PostMutImpMockUpdateEnableCommentToPostExpectation{}
	}

	if mmUpdateEnableCommentToPost.defaultExpectation.params != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Expect")
	}

	if mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs == nil {
		mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs = &PostMutImpMockUpdateEnableCommentToPostParamPtrs{}
	}
	mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs.authorID = &authorID
	mmUpdateEnableCommentToPost.defaultExpectation.expectationOrigins.originAuthorID = minimock.CallerInfo(1)

	return mmUpdateEnableCommentToPost
}

// ExpectCommentsEnabledParam4 sets up expected param commentsEnabled for PostMutImp.UpdateEnableCommentToPost
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) ExpectCommentsEnabledParam4(commentsEnabled bool) *mPostMutImpMockUpdateEnableCommentToPost {
	if mmUpdateEnableCommentToPost.mock.funcUpdateEnableCommentToPost != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Set")
	}

	if mmUpdateEnableCommentToPost.defaultExpectation == nil {
		mmUpdateEnableCommentToPost.defaultExpectation = &PostMutImpMockUpdateEnableCommentToPostExpectation{}
	}

	if mmUpdateEnableCommentToPost.defaultExpectation.params != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Expect")
	}

	if mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs == nil {
		mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs = &PostMutImpMockUpdateEnableCommentToPostParamPtrs{}
	}
	mmUpdateEnableCommentToPost.defaultExpectation.paramPtrs.commentsEnabled = &commentsEnabled
	mmUpdateEnableCommentToPost.defaultExpectation.expectationOrigins.originCommentsEnabled = minimock.CallerInfo(1)

	return mmUpdateEnableCommentToPost
}

// Inspect accepts an inspector function that has same arguments as the PostMutImp.UpdateEnableCommentToPost
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) Inspect(f func(ctx context.Context, postID int64, authorID uuid.UUID, commentsEnabled bool)) *mPostMutImpMockUpdateEnableCommentToPost {
	if mmUpdateEnableCommentToPost.mock.inspectFuncUpdateEnableCommentToPost != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("Inspect function is already set for PostMutImpMock.UpdateEnableCommentToPost")
	}

	mmUpdateEnableCommentToPost.mock.inspectFuncUpdateEnableCommentToPost = f

	return mmUpdateEnableCommentToPost
}

// Return sets up results that will be returned by PostMutImp.UpdateEnableCommentToPost
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) Return(pp1 *model.Post, err error) *PostMutImpMock {
	if mmUpdateEnableCommentToPost.mock.funcUpdateEnableCommentToPost != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Set")
	}

	if mmUpdateEnableCommentToPost.defaultExpectation == nil {
		mmUpdateEnableCommentToPost.defaultExpectation = &PostMutImpMockUpdateEnableCommentToPostExpectation{mock: mmUpdateEnableCommentToPost.mock}
	}
	mmUpdateEnableCommentToPost.defaultExpectation.results = &PostMutImpMockUpdateEnableCommentToPostResults{pp1, err}
	mmUpdateEnableCommentToPost.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateEnableCommentToPost.mock
}

// Set uses given function f to mock the PostMutImp.UpdateEnableCommentToPost method
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) Set(f func(ctx context.Context, postID int64, authorID uuid.UUID, commentsEnabled bool) (pp1 *model.Post, err error)) *PostMutImpMock {
	if mmUpdateEnableCommentToPost.defaultExpectation != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("Default expectation is already set for the PostMutImp.UpdateEnableCommentToPost method")
	}

	if len(mmUpdateEnableCommentToPost.expectations) > 0 {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("Some expectations are already set for the PostMutImp.UpdateEnableCommentToPost method")
	}

	mmUpdateEnableCommentToPost.mock.funcUpdateEnableCommentToPost = f
	mmUpdateEnableCommentToPost.mock.funcUpdateEnableCommentToPostOrigin = minimock.CallerInfo(1)
	return mmUpdateEnableCommentToPost.mock
}

// When sets expectation for the PostMutImp.UpdateEnableCommentToPost which will trigger the result defined by the following
// Then helper
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) When(ctx context.Context, postID int64, authorID uuid.UUID, commentsEnabled bool) *PostMutImpMockUpdateEnableCommentToPostExpectation {
	if mmUpdateEnableCommentToPost.mock.funcUpdateEnableCommentToPost != nil {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("PostMutImpMock.UpdateEnableCommentToPost mock is already set by Set")
	}

	expectation := &PostMutImpMockUpdateEnableCommentToPostExpectation{
		mock:               mmUpdateEnableCommentToPost.mock,
		params:             &PostMutImpMockUpdateEnableCommentToPostParams{ctx, postID, authorID, commentsEnabled},
		expectationOrigins: PostMutImpMockUpdateEnableCommentToPostExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateEnableCommentToPost.expectations = append(mmUpdateEnableCommentToPost.expectations, expectation)
	return expectation
}

// Then sets up PostMutImp.UpdateEnableCommentToPost return parameters for the expectation previously defined by the When method
func (e *PostMutImpMockUpdateEnableCommentToPostExpectation) Then(pp1 *model.Post, err error) *PostMutImpMock {
	e.results = &PostMutImpMockUpdateEnableCommentToPostResults{pp1, err}
	return e.mock
}

// Times sets number of times PostMutImp.UpdateEnableCommentToPost should be invoked
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) Times(n uint64) *mPostMutImpMockUpdateEnableCommentToPost {
	if n == 0 {
		mmUpdateEnableCommentToPost.mock.t.Fatalf("Times of PostMutImpMock.UpdateEnableCommentToPost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateEnableCommentToPost.expectedInvocations, n)
	mmUpdateEnableCommentToPost.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateEnableCommentToPost
}

func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) invocationsDone() bool {
	if len(mmUpdateEnableCommentToPost.expectations) == 0 && mmUpdateEnableCommentToPost.defaultExpectation == nil && mmUpdateEnableCommentToPost.mock.funcUpdateEnableCommentToPost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateEnableCommentToPost.mock.afterUpdateEnableCommentToPostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateEnableCommentToPost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateEnableCommentToPost implements PostMutImp
func (mmUpdateEnableCommentToPost *PostMutImpMock) UpdateEnableCommentToPost(ctx context.Context, postID int64, authorID uuid.UUID, commentsEnabled bool) (pp1 *model.Post, err error) {
	mm_atomic.AddUint64(&mmUpdateEnableCommentToPost.beforeUpdateEnableCommentToPostCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateEnableCommentToPost.afterUpdateEnableCommentToPostCounter, 1)

	mmUpdateEnableCommentToPost.t.Helper()

	if mmUpdateEnableCommentToPost.inspectFuncUpdateEnableCommentToPost != nil {
		mmUpdateEnableCommentToPost.inspectFuncUpdateEnableCommentToPost(ctx, postID, authorID, commentsEnabled)
	}

	mm_params := PostMutImpMockUpdateEnableCommentToPostParams{ctx, postID, authorID, commentsEnabled}

	// Record call args
	mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.mutex.Lock()
	mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.callArgs = append(mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.callArgs, &mm_params)
	mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.mutex.Unlock()

	for _, e := range mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.defaultExpectation.paramPtrs

		mm_got := PostMutImpMockUpdateEnableCommentToPostParams{ctx, postID, authorID, commentsEnabled}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateEnableCommentToPost.t.Errorf("PostMutImpMock.UpdateEnableCommentToPost got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmUpdateEnableCommentToPost.t.Errorf("PostMutImpMock.UpdateEnableCommentToPost got unexpected parameter postID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.defaultExpectation.expectationOrigins.originPostID, *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

			if mm_want_ptrs.authorID != nil && !minimock.Equal(*mm_want_ptrs.authorID, mm_got.authorID) {
				mmUpdateEnableCommentToPost.t.Errorf("PostMutImpMock.UpdateEnableCommentToPost got unexpected parameter authorID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.defaultExpectation.expectationOrigins.originAuthorID, *mm_want_ptrs.authorID, mm_got.authorID, minimock.Diff(*mm_want_ptrs.authorID, mm_got.authorID))
			}

			if mm_want_ptrs.commentsEnabled != nil && !minimock.Equal(*mm_want_ptrs.commentsEnabled, mm_got.commentsEnabled) {
				mmUpdateEnableCommentToPost.t.Errorf("PostMutImpMock.UpdateEnableCommentToPost got unexpected parameter commentsEnabled, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.defaultExpectation.expectationOrigins.originCommentsEnabled, *mm_want_ptrs.commentsEnabled, mm_got.commentsEnabled, minimock.Diff(*mm_want_ptrs.commentsEnabled, mm_got.commentsEnabled))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateEnableCommentToPost.t.Errorf("PostMutImpMock.UpdateEnableCommentToPost got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateEnableCommentToPost.UpdateEnableCommentToPostMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateEnableCommentToPost.t.Fatal("No results are set for the PostMutImpMock.UpdateEnableCommentToPost")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmUpdateEnableCommentToPost.funcUpdateEnableCommentToPost != nil {
		return mmUpdateEnableCommentToPost.funcUpdateEnableCommentToPost(ctx, postID, authorID, commentsEnabled)
	}
	mmUpdateEnableCommentToPost.t.Fatalf("Unexpected call to PostMutImpMock.UpdateEnableCommentToPost. %v %v %v %v", ctx, postID, authorID, commentsEnabled)
	return
}

// UpdateEnableCommentToPostAfterCounter returns a count of finished PostMutImpMock.UpdateEnableCommentToPost invocations
func (mmUpdateEnableCommentToPost *PostMutImpMock) UpdateEnableCommentToPostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEnableCommentToPost.afterUpdateEnableCommentToPostCounter)
}

// UpdateEnableCommentToPostBeforeCounter returns a count of PostMutImpMock.UpdateEnableCommentToPost invocations
func (mmUpdateEnableCommentToPost *PostMutImpMock) UpdateEnableCommentToPostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEnableCommentToPost.beforeUpdateEnableCommentToPostCounter)
}

// Calls returns a list of arguments used in each call to PostMutImpMock.UpdateEnableCommentToPost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateEnableCommentToPost *mPostMutImpMockUpdateEnableCommentToPost) Calls() []*PostMutImpMockUpdateEnableCommentToPostParams {
	mmUpdateEnableCommentToPost.mutex.RLock()

	argCopy := make([]*PostMutImpMockUpdateEnableCommentToPostParams, len(mmUpdateEnableCommentToPost.callArgs))
	copy(argCopy, mmUpdateEnableCommentToPost.callArgs)

	mmUpdateEnableCommentToPost.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateEnableCommentToPostDone returns true if the count of the UpdateEnableCommentToPost invocations corresponds
// the number of defined expectations
func (m *PostMutImpMock) MinimockUpdateEnableCommentToPostDone() bool {
	if m.UpdateEnableCommentToPostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateEnableCommentToPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateEnableCommentToPostMock.invocationsDone()
}

// MinimockUpdateEnableCommentToPostInspect logs each unmet expectation
func (m *PostMutImpMock) MinimockUpdateEnableCommentToPostInspect() {
	for _, e := range m.UpdateEnableCommentToPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostMutImpMock.UpdateEnableCommentToPost at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateEnableCommentToPostCounter := mm_atomic.LoadUint64(&m.afterUpdateEnableCommentToPostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateEnableCommentToPostMock.defaultExpectation != nil && afterUpdateEnableCommentToPostCounter < 1 {
		if m.UpdateEnableCommentToPostMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostMutImpMock.UpdateEnableCommentToPost at\n%s", m.UpdateEnableCommentToPostMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostMutImpMock.UpdateEnableCommentToPost at\n%s with params: %#v", m.UpdateEnableCommentToPostMock.defaultExpectation.expectationOrigins.origin, *m.UpdateEnableCommentToPostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateEnableCommentToPost != nil && afterUpdateEnableCommentToPostCounter < 1 {
		m.t.Errorf("Expected call to PostMutImpMock.UpdateEnableCommentToPost at\n%s", m.funcUpdateEnableCommentToPostOrigin)
	}

	if !m.UpdateEnableCommentToPostMock.invocationsDone() && afterUpdateEnableCommentToPostCounter > 0 {
		m.t.Errorf("Expected %d calls to PostMutImpMock.UpdateEnableCommentToPost at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateEnableCommentToPostMock.expectedInvocations), m.UpdateEnableCommentToPostMock.expectedInvocationsOrigin, afterUpdateEnableCommentToPostCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PostMutImpMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddPostInspect()

			m.MinimockUpdateEnableCommentToPostInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PostMutImpMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PostMutImpMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddPostDone() &&
		m.MinimockUpdateEnableCommentToPostDone()
}
